# Сортировка слиянием

Дан массив целых чисел.  Ваша задача -- отсортировать его в порядке неубывания с помощью сортировки слиянием.

Чтобы убедиться, что Вы действительно используете сортировку слиянием, мы просим Вас после каждого осуществленного слияния (то есть, когда соответствующий подмассив уже отсортирован!), выводить индексы граничных элементов и их значения.

### Формат входного файла

В первой строке входного файла содержится число ![n](https://latex.codecogs.com/svg.latex?n) (![1 \leqslant n \leqslant 10^5](https://latex.codecogs.com/svg.latex?1%20\leqslant%20n%20\leqslant%2010^5)) -- число элементов в массиве.  Во второй строке находятся ![n](https://latex.codecogs.com/svg.latex?n) целых чисел, по модулю не превосходящих ![10^9](https://latex.codecogs.com/svg.latex?10^9).

### Формат выходного файла

Выходной файл состоит из нескольких строк.

В **последней строке** выходного файла требуется вывести отсортированный в порядке неубывания массив, данный на входе.  Между любыми двумя числами должен стоять ровно один пробел.

Все предшествующие строки описывают осуществленные слияния, по одному на каждой строке.  Каждая такая строка должна содержать по четыре числа: ![I_f I_l V_f V_l](https://latex.codecogs.com/svg.latex?I_f\%20I_l\%20V_f\%20V_l), где ![I_f](https://latex.codecogs.com/svg.latex?I_f) -- индекс начала области слияния, ![I_l](https://latex.codecogs.com/svg.latex?I_l) -- индекс конца области слияния, ![V_f](https://latex.codecogs.com/svg.latex?V_f) -- значение первого элемента области слияния, ![V_l](https://latex.codecogs.com/svg.latex?V_l) -- значение последнего элемента области слияния.

Все индексы начинаются с единицы (то есть, ![1 \leqslant I_f \leqslant I_l \leqslant n](https://latex.codecogs.com/svg.latex?1%20\leqslant%20I_f%20\leqslant%20I_l%20\leqslant%20n)).  **Индексы области слияния должны описывать положение области слияния в исходном массиве!**  Допускается не выводить информацию о слиянии для подмассива длиной 1, так как он отсортирован по определению.

Приведем небольшой пример: отсортируем массив `[9, 7, 5, 8]`.  Рекурсивная часть сортировки слиянием (процедура `SORT(A, L, R)`, где `A` -- сортируемый массив, `L` -- индекс начала области слияния, `R` -- индекс конца области слияния) будет вызвана с `A = [9, 7, 5, 80], L = 1, R = 4` и выполнит следующие действия:

- разделит область слияния `[1; 4]` на две части, `[1; 2]` и `[3; 4]`;
- выполнит вызов `SORT(A, L = 1, R = 2)`:
  - разделит область слияния `[1; 2]` на две части, `[1; 1]` и `[2; 2]`;
  - получившиеся части имеют единичный размер, рекурсивные вызовы можно не делать;
  - осуществит слияние, после чего `A` станет равным `[7, 9, 5, 8]`;
  - выведет описание слияния: ![I_f = L = 1, I_l = R = 2, V_f = A_L = 7, V_l = A_R = 9](https://latex.codecogs.com/svg.latex?I_f=L=1,%20I_l=R=2,%20V_f=A_L=7,%20V_l=A_R=9).
- выполнит вызов `SORT(A, L = 3, R = 4)`:
  - разделит область слияния `[3; 4]` на две части, `[3; 3]` и `[4; 4]`;
  - получившиеся части имеют единичный размер, рекурсивные вызовы можно не делать;
  - осуществит слияние, после чего `A` станет равным `[7, 9, 5, 8]`;
  - выведет описание слияния: ![I_f = L = 3, I_l = R = 4, V_f = A_L = 5, V_l = A_R = 8](https://latex.codecogs.com/svg.latex?I_f=L=3,%20I_l=R=4,%20V_f=A_L=5,%20V_l=A_R=8).
- осуществит слияние, после чего `A` станет равным `[5, 7, 8, 9]`;
- выведет описание слияния: ![I_f = L = 1, I_l = R = 4, V_f = A_L = 5, V_l = A_R = 9](https://latex.codecogs.com/svg.latex?I_f=L=1,%20I_l=R=4,%20V_f=A_L=5,%20V_l=A_R=9).

Описания слияний могут идти в произвольном порядке, необязательно совпадающем с порядком их выполнения.  Однако, с целью повышения производительности рекомендуем выводить эти описания сразу, не храня их в памяти.  Именно по этой причине отсортированный массив выводится в самом конце.

**Исключением из этого правила, возможно, является PyPy** -- по причине отсутствия буферизации вывода, при решения задачи на этом языке рекомендуется собрать все описания слияния в один буфер, а затем вывести его как одно целое.  Обертка ввода-вывода для PyPy, расположенная на [GitHub](https://github.com/mbuzdalov/edx-io/blob/master/src/python/edx_io.py) и доступная (при компиляции решения в тестирующей системе) как модуль `openedu_io`, делает это автоматически.

Корректность выданного Вами сценария сортировки слиянием проверяется специальной программой.  Любая корректная сортировка слиянием, делящая подмассивы на две части (необязательно равных!), будет зачтена, если успеет завершиться, уложившись в ограничения.

### Пример

`input.txt`
```
10
1 8 2 1 4 7 3 2 3 6
```

`output.txt`
```
1 2 1 8
3 4 1 2
1 4 1 8
5 6 4 7
1 6 1 8
7 8 2 3
9 10 3 6
7 10 2 6
1 10 1 8
1 1 2 2 3 3 4 6 7 8
```

### Решение

[MergeSort.scala](MergeSort.scala)
