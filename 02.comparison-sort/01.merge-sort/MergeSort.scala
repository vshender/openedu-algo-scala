/* Сортировка слиянием
 *
 * Дан массив целых чисел.  Ваша задача -- отсортировать его в порядке
 * неубывания с помощью сортировки слиянием.
 *
 * Чтобы убедиться, что Вы действительно используете сортировку слиянием, мы
 * просим Вас после каждого осуществленного слияния (то есть, когда
 * соответствующий подмассив уже отсортирован!), выводить индексы граничных
 * элементов и их значения.
 *
 * Формат входного файла:
 *
 * В первой строке входного файла содержится число n (1 <= n <= 10^5) -- число
 * элементов в массиве.  Во второй строке находятся n целых чисел, по модулю не
 * превосходящих 10^9.
 *
 * Формат выходного файла:
 *
 * Выходной файл состоит из нескольких строк.
 *
 * В *последней строке* выходного файла требуется вывести отсортированный в
 * порядке неубывания массив, данный на входе.  Между любыми двумя числами
 * должен стоять ровно один пробел.
 *
 * Все предшествующие строки описывают осуществленные слияния, по одному на
 * каждой строке.  Каждая такая строка должна содержать по четыре числа:
 * I_f, I_l, V_f, V_l, где
 * - I_f -- индекс начала области слияния,
 * - I_l -- индекс конца области слияния,
 * - V_f -- значение первого элемента области слияния,
 * - V_l -- значение последнего элемента области слияния.
 *
 * Все индексы начинаются с единицы (то есть, 1 <= I_f <= I_l <= n).  *Индексы
 * области слияния должны описывать положение области слияния в исходном
 * массиве!*  Допускается не выводить информацию о слиянии для подмассива
 * длиной 1, так как он отсортирован по определению.
 *
 * Приведем небольшой пример: отсортируем массив [9, 7, 5, 8].  Рекурсивная
 * часть сортировки слиянием (процедура SORT(A, L, R), где A -- сортируемый
 * массив, L -- индекс начала области слияния, R -- индекс конца области
 * слияния) будет вызвана с A = [9, 7, 5, 80], L = 1, R = 4 и выполнит следующие
 * действия:
 * - разделит область слияния [1; 4] на две части, [1; 2] и [3; 4];
 * - выполнит вызов SORT(A, L = 1, R = 2):
 *   - разделит область слияния [1; 2] на две части, [1; 1] и [2; 2];
 *   - получившиеся части имеют единичный размер, рекурсивные вызовы можно не
 *     делать;
 *   - осуществит слияние, после чего A станет равным [7, 9, 5, 8];
 *   - выведет описание слияния: I_f = L = 1, I_l = R = 2, V_f = A_L = 7,
 *      V_l = A_R = 9.
 * - выполнит вызов SORT(A, L = 3, R = 4):
 *   - разделит область слияния [3; 4] на две части, [3; 3] и [4; 4];
 *   - получившиеся части имеют единичный размер, рекурсивные вызовы можно не
 *     делать;
 *   - осуществит слияние, после чего A станет равным [7, 9, 5, 8];
 *   - выведет описание слияния: I_f = L = 3, I_l = R = 4, V_f = A_L = 5,
 *     V_l = A_R = 8.
 * - осуществит слияние, после чего A станет равным [5, 7, 8, 9];
 * - выведет описание слияния: I_f = L = 1, I_l = R = 4, V_f = A_L = 5,
 *    V_l = A_R = 9.
 *
 * Описания слияний могут идти в произвольном порядке, необязательно
 * совпадающем с порядком их выполнения.  Однако, с целью повышения
 * производительности рекомендуем выводить эти описания сразу, не храня их в
 * памяти.  Именно по этой причине отсортированный массив выводится в самом
 * конце.
 *
 * *Исключением из этого правила, возможно, является PyPy* -- по причине
 * отсутствия буферизации вывода, при решения задачи на этом языке
 * рекомендуется собрать все описания слияния в один буфер, а затем вывести его
 * как одно целое.  Обертка ввода-вывода для PyPy, расположенная на GitHub
 * (https://github.com/mbuzdalov/pads-io/blob/master/pypy/openedu_io.py) и
 * доступная (при компиляции решения в тестирующей системе) как модуль
 * `openedu_io`, делает это автоматически.
 *
 * Корректность выданного Вами сценария сортировки слиянием проверяется
 * специальной программой.  Любая корректная сортировка слиянием, делящая
 * подмассивы на две части (необязательно равных!), будет зачтена, если успеет
 * завершиться, уложившись в ограничения.
 *
 * Пример:
 *
 * input.txt:
 *   10
 *   1 8 2 1 4 7 3 2 3 6
 * output.txt:
 *   1 2 1 8
 *   3 4 1 2
 *   1 4 1 8
 *   5 6 4 7
 *   1 6 1 8
 *   7 8 2 3
 *   9 10 3 6
 *   7 10 2 6
 *   1 10 1 8
 *   1 1 2 2 3 3 4 6 7 8
 */

import java.io.{FileReader, FileWriter, PrintWriter}
import java.util.Scanner
import scala.reflect.ClassTag
import scala.util.Using

object MergeSort {
  def mergeSort[T](array: Array[T], debug: (Int, Int, T, T) => Unit = null)
    (implicit ordering: Ordering[T], t: ClassTag[T]): Unit = {

    val tmp = new Array[T](array.length)
    val debugOpt = if (debug eq null) None else Some(debug)

    def merge(l: Int, m: Int, r: Int): Unit = {
      var (i, j, k) = (l, m, l)
      while (i < m || j < r) {
        if (j == r || (i < m && ordering.lt(array(i), array(j)))) {
          tmp(k) = array(i)
          i += 1
        } else {
          tmp(k) = array(j)
          j += 1
        }
        k += 1
      }

      for (k <- l until r)
        array(k) = tmp(k)
    }

    def sort(l: Int, r: Int): Unit = {
      if (l == r - 1)
        return

      val m = l + (r - l) / 2
      sort(l, m)
      sort(m, r)

      merge(l, m, r)

      debugOpt.foreach(_(l, r - 1, array(l), array(r - 1)))
    }

    sort(0, array.length)
  }

  def main(args: Array[String]): Unit = {
    val array = Using.resource(new Scanner(new FileReader("input.txt"))) { in =>
      val n = in.nextInt()
      Array.fill[Int](n)(in.nextInt())
    }

    Using.resource(new PrintWriter(new FileWriter("output.txt"))) { out =>
      mergeSort(
        array,
        (left: Int, right: Int, leftVal: Int, rightVal: Int) =>
          out.printf("%d %d %d %d\n", left + 1, right + 1, leftVal, rightVal),
      )

      array.foreach(x => out.printf("%d ", x))
      out.println()
    }
  }
}
