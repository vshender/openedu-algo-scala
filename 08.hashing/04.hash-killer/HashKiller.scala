/* Убийца хешей
 *
 * При хешировании строк широко используются полиномиальные хеши.  Код,
 * вычисляющий полиномиальный хеш, приведен на листинге ниже.  В этом коде
 * `int` -- это 32-битное знаковое число.  Множитель `multiple` обычно либо
 * жестко фиксируется, либо генерируется каким-либо образом один раз на весь
 * сеанс работы со строками.
 *
 *   int multiple = ???;
 *   public int hashOf(String s) {
 *     int rv = 0;
 *     for (int i = 0; i < s.length(); ++i) {
 *       rv = multiple * rv + s.charAt(i);
 *     }
 *     return rv;
 *   }
 *
 * Вычисление полиномиальных хешей можно производить эффективно (и даже
 * параллельно), кроме того, они могут быть эффективно пересчитаны при
 * добавлении и удалении символов (в начало, в конец и даже в произвольное
 * место строки), а также при конкатенации и разрыве строк.
 *
 * Однако у полиномиальных хешей есть и недостаток: для них легко подобрать
 * строки с совпадающими хешами.  Ваша задача -- сделать это для /всех
 * множителей/ от 2 до 1023 включительно.  Сгенерируйте N строк таким образом,
 * чтобы для каждого из этих множителей хеши всех этих строк совпадали.
 *
 * Более формально, пусть H_m(S) -- полиномиальный хеш строки S с множителем
 * m.  Требуется сгенерировать набор из N строк S_1, ..., S_N, такой что для
 * всех 2 <= m <= 1023 выполнялось H_m(S_1) = ... = H_m(S_N).
 *
 * Формат входного файла:
 *
 * Входной файл содержит одно целое число N (1 <= N <= 10^4).
 *
 * Формат выходного файла:
 *
 * Выведите N строк. Строки должны быть непусты, должны состоять из строчных
 * латинских букв.  Длина каждой из строк не должна превосходить 2500.  *Все
 * строки должны быть различными!*
 *
 * Пример:
 *
 * input.txt:
 *   1
 * output.txt
 *   hello
 */

/* Решение основано на методе взлома полиномиальных хешей с помощью
 * последовательностей Морса-Туэ.
 *   https://codeforces.com/blog/entry/4898
 */

import java.io.{FileReader, FileWriter, PrintWriter}
import java.util.Scanner
import scala.collection.mutable.Buffer
import scala.util.Using

object HashKiller {
  /* Вычисление полиномиального хеша с указанным множителем.
   *
   * Этот метод использовался для тестов и отладки и не нужен в самом решении.
   */
  def hashOf(s: String, m: Int): Int =
    s.foldLeft(0)((h, c) => h * m + c)

  /* Построить последовательность Морса-Туэ длины `n` из бука "a" и "b". */
  def thueMorseSequence(n: Int): String =
    Array.tabulate[Char](n)((i: Int) => ('a' + Integer.bitCount(i) % 2).toChar).mkString

  /* "Инвертировать" последовательность из букв "a" и "b". */
  def inverse(s: String): String =
    Array.tabulate[Char](s.length)((i: Int) => (if (s(i) == 'a') 'b' else 'a')).mkString

  /* 2^7 -- минимальная длина последовательности Морса-Туэ, при которой
   * приведенная выше реализация полиномиальной хеш-функции (с 32-битным целым)
   * дает одинаковые значения хеша на данной последовательности и ее инверсии
   * для всех нечетных множителей.
   *
   * Теперь, в силу свойств полиномиальных хешей, мы можем составлять
   * конкатенации произвольного числа данных двух последовательностей, и все
   * составленные последовательности одинаковой длины будут иметь одинаковое
   * значение хеша.  Таким образом мы сможем сгенерировать нужное число строк.
   */
  val oddKillers = Array(thueMorseSequence(128), inverse(thueMorseSequence(128)))

  /* При четном значении множителя в вышеприведенной реализации значение хеша
   * зависит в лучшем случае от последних 32 символов, так как весь вклад
   * предшествующих символов оказался умноженным на 2^32 (минимум, при
   * множителе равном 2).  Следовательно, любая строка с нижеприведенным
   * суффиксом будет давать одинаковые значения хеша при четных множителях.
   */
  val evenKiller = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

  /* Вернуть битовое представление числа `n` длины `len`. */
  def getNumberBits(len: Int, n: Int): Array[Byte] = {
    val bits = new Array[Byte](len)
    (0 until len).foldLeft(n)((n, i) => {
      bits(i) = (n % 2).toByte;
      n / 2
    })
    bits
  }

  /* Сгенерировать `i`-ую строку, дающую одинаковое значение хеша.
   *
   * `i` может находиться в диапазоне 0 .. 2^14-1 = 16383, чего заведомо хватит
   * для генерации 10^4 строк.
   */
  def genHashKiller(i: Int): String = {
    val buf = Buffer[String]()
    for (b <- getNumberBits(14, i))
      buf += oddKillers(b)
    buf += evenKiller
    buf.mkString
  }

  def main(args: Array[String]): Unit = {
    val n = Using.resource(new Scanner(new FileReader("input.txt"))) { in =>
      in.nextInt()
    }

    Using.resource(new PrintWriter(new FileWriter("output.txt"))) { out =>
      for (i <- 0 until n)
        out.println(genHashKiller(i))
    }
  }
}
